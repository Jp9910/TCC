\chapter{Fundamentação teórica}\label{cap_exemplos}

\chapterprecis{Introdução sobre arquitetura de microserviços e DevOps, revisão da literatura.}\index{sinopse de capítulo}

\section{Os monolitos}

Aplicações monolíticas são aplicações que possuem camadas de acesso aos dados e de interface de usuário em um único programa em uma única plataforma. Os monolitos são autocontidos e totalmente independentes de outras aplicações. Eles são feitos não para uma tarefa em particular, mas sim para serem responsáveis por todo o processo para completar determinada função. Em outras palavras, as aplicações monolíticas não têm modularidade. Elas podem ser organizadas das mais variadas formas, e fazer uso de padrões arquiteturais, mas são limitadas em muitos outros aspectos.

\subsection{Benefícios}

Simples. Fácil de construir. Até certo tamanho, é mais fácil de manter.

\subsection{Limitações}

Crescimento, escalamento, manutenção, reutilização, flexibilidade

% ---
\section{O que são microserviços}
% ---

The term microservice can be a bit misleading. The prefix “micro” implies that microservices are either tiny little entities. Microservices do work on our behalf but they are not always tiny. The “micro” in microservices is actually in reference to the scope of functionality that the service provides

A microservice provides a business or platform capability through a well-defined API, data contract, and configuration. It provides this function and only this function. It does one thing and it does it well. This simple concept provides the foundation for a framework that will guide the design, development, and deployment of your microservices.

Within the context of doing one thing and doing it well, microservices also exhibit a number of other properties and behaviors; it is these elements that differentiate microservices from previous incarnations of service-oriented approaches.

\subsection{Autonomia e Isolamento}
Autonomia e isolamento significa que microserviços são unidades auto-contidas de funcionalidade com dependências de outros serviços fracamente acopladas e são projetados, desenvolvidos, testados e lançados independentemente.

Autônomo - Existe ou é capaz de existir independetemente das outras partes.

Isolado - Separado das outras partes. 


\subsubsection*{Implicações}
For the past several years, we have been developing standards and practices for team development of large, complex systems using a layered, monolithic architecture. This is reflected in how we organize into teams, structure our solutions and source code control systems, and package and release our software. Monolithic solutions are built, tested, and deployed as one large body of code, typically across set of server or VM instances, in order to provide scale and performance. If a bug is fixed or a feature added or content updated, the entire solution is built, tested, and deployed across the server farm as one large entity. The process of building, deploying, and regression testing the monolith is costly and time-consuming. Over time, these monoliths turn into large, complex, tightly coupled systems that are nearly impossible to maintain and evolve in new directions. If you want to adopt a microservices architecture, your standards and practices will need to adapt to this new pattern. Teams will need to be organized in such a way as to support the development of microservices as distinct, independent products. The development, test, and production environments will need to be organized to support these teams, developing and deploying their microservice products separate of one another. When changes are made, only the microservice affected needs to go through the deployment pipeline, thus simplifying the process of updating the system and delivering new features and functions. By dividing the solution up into its microservice component parts and treating them as separate development efforts, the speed of development will increase and the cost of making changes will go down.

\subsection{São elásticos, resilientes, e responsivos}

Elastic: Capable of returning to its original length, shape, etc., after being stretched, deformed, compressed, or expanded.

Resilient: Able to become strong, healthy, or successful again after something bad happens.

Responsive: Quick to respond or react.

Microserviços são reusados entre muitas soluções diferentes e portanto devem ser escaláveis de acordo com o uso. Devem ser tolerantes a falhas e ter um tempo de recuperação razoável se algo der errado. E também devem ser responsivos, tendo um desempenho razoável de acordo com o uso.

\subsubsection*{Implicações}

The environment in which you deploy your microservices must provide dynamic scale and high availability configurations for both stateful and stateless services. This is achieved by leveraging a modern cloud platform such as Microsoft Azure. Azure provides all the necessary capabilities to support elastic scale, fault tolerance, and high availability as well as configuration options that allow you the right size for performance. You will delve into how Azure is a microservices platform in greater detail in Chapter 4.

\subsection{São orientados-a-mensagens e programáveis}

Orientado-a-mensagens: Software que conecta sistemas separados em uma rede, carregando e distribuindo mensagens entre eles.

Programável: Um plano de tarefas que são executadas com para alcançar um objetivo específico.

Microserviços dependem de APIs e contratos de dados para definir como interagir com o serviço. A API define um conjunto de endpoints acessíveis por rede, e o contrato de dados define a estrutura da mensagem que é enviada ou retornada.

\subsubsection{Implicações}

Defining service end points and data contracts is not new. Microservice architecture builds on the evolution of industry standards to define the interaction semantics. If these standards evolve or new ones are introduced, a microservice architecture will evolve to adopt these new standards. 
At the time of this writing, the industry has generally settled on Representational State Transfer (ReST) over HTTP for defining API endpoints and JavaScript Object Notation (JSON) for the definition of data contracts. In addition, service bus capabilities such as store and forward message queues are used to provide loose coupling between components and an asynchronous programming model.

APIs and data contracts are the outermost edge of a microservice and define how a client of the service can invoke a function. Behind this API may be a very sophisticated set of software components, storage mediums, and multiple VM instances that provide the function. To the consumer of the service this is all a black box, meaning they know the published inputs and outputs but nothing else about the inner workings. As a consumer of that service, they have knowledge of the published inputs and outputs, and nothing more. What is expected is that a message is constructed, the API is invoked, and a response is returned. The interaction between the consumer and the service is finite and distinct.

\subsection{São configuráveis}

Configurável: Projetado ou adaptado para formar uma configuração ou para algum propósito.

Microserviços devem provêr mais do que apenas uma API e um contrato de dados. Para que seja reusável e para que possa resolver as necessidades de que sistema que o use, cada microserviço tem níveis diferentes de configuração, e esta configuração pode ser feita de diferentes formas.

\subsubsection*{Implicações}

As you begin the design process for a microservice, you will soon discover that multiple APIs will emerge. Along with the public-facing API that you want to expose to the world, other endpoints will surface that are more of an administrative function and will be used to define how to bootstrap, monitor, manage, scale, configure, and perform other perfunctory operations on the service. Like any good software product, a microservice should provide an easy-to-use interface or console for administrative functions to configure and manage running instances. Behind the console is, of course, a set of private to semi-private APIs that provides access to the underlying data and configuration settings driving the service. A microservice, then, is more than just its public-facing ReST API and consists of multiple APIs with varying levels of access, supporting administrative consoles and a runtime infrastructure to support all of the above. It is a software product with all the trimmings.

\subsection {São automatizados}

Automatizados: Funcionar sem precisar ser controlado diretamente.

O ciclo de vida de um microserviço é totalmente automaticazado, desde o design até a implantação.

\subsubsection*{Implicações}

As you ponder this new world of software product development made up of microservices, it may occur to you that this whole effort could be quite complex with a proliferation of independent microservice products and all the complexity that entails, and you would not be wrong. This approach should not be undertaken without first having complete automated control over the software development lifecycle. This is about having the right set of tools to support a fully automated development pipeline, but more importantly it is about evolving to a DevOps culture. A DevOps culture is one that promotes collaboration and integration of the development and operations teams. When you form a team that is responsible for the design, implementation, and deployment of a microservice, that team should be cross functional, consisting of all the skills necessary to carry the process from design through deployment. That means that traditional development teams consisting of architects, developers, and testers should be expanded to include operations. While developers are traditionally responsible for the automation from build through test, called continuous integration, the operations group is traditionally responsible for deployment across test, staging, and production. Combining these teams offers the opportunity to make automation of the entire product development pipeline as well as the monitoring, diagnostics, and recovery operations a first class activity of the product team. This process is called automation, and the entire team takes responsibility for smooth operation of product releases.

\section{A arquitetura de microserviços}

Microserviços são uma abordagem arquitetônica e organizacional do desenvolvimento de software na qual o software consiste em pequenos serviços independentes que se comunicam usando APIs bem definidas. Esses serviços pertecem a pequenas equipes autossuficientes.

A arquitetura de microserviços (AMS) está ganhando força no desenvolvimento e entrega de aplicações de software como um conjunto de pequenos serviços granulares que podem ser integrados por meio de mecanismos de comunicação leve, normalmente APIs RESTful [10]. Microserviços são componentes pequenos e facilmente entendíveis que possuem capacidades de negócio no meio dos serviços [11]. Esses serviços podem ser escalados independentemente (já que são desacoplados) pela implementação de \texttt{stacks} de tecnologias diferentes [2]. Muitos pesquisadores e praticantes dizem que AMS é uma evolução da Arquitetura orientada a serviços (AOS), como visto no contexto de serviços independentes/auto-suficientes e de natureza leve [12]. Por outro lado, AMS pode ser diferenciada da AOS em termos de compartilhamento de componentes, comunicação de serviços, mediação de serviços, e acesso remoto aos serviços [13]. (Bar, f., 2018, tradução nossa). \cite{WASEEM2020110798}
% AOS é construida com base na ideia de compartilhar o máximo possível, enquanto AMS, o mínimo possível [13, 14]. AMS usa um estilo coreografico para comunicação inter-serviços, enquanto AOS aplica um estilo de orquestração para coordenação de serviços. Para mediação de serviços, AMS usa a camada de API que atua como uma fachada para o serviço, enquanto AOS adota o conceito de um \texttt{middleware} mensageiro para coodenação de serviços. Além disso, AMS em grande parte depende do protocolo REST e mensageria simples como protocolo de acesso remoto ao serviço; entretanto, AOS consegue lidar com diferentes tipos de protocolo de acesso remoto, incluindo mensageria simples para acessar serviços remotos [13].

De acordo com Fowler, M., existem alguns pré-requisitos para começar a aplicar a usar a arquitetura de microserviços em um projeto - Provisionamento rápido, monitamento básico, e entrega (deployment) rápido.



All of these services and the infrastructures where the services are developed, tested, and deployed require robust automation to handle the number of the processes and velocity of change [19]. It is argued that DevOps can reduce the impact of the challenges related to MSA development and operations [20]

\section{Vantagens da arquitetura de microserviços}

\subsection{Evolução}

Quanto maior e mais antigo o software, mais difícil é de dar manutenção, e monolitos envelhecem com maior velocidade do que microserviços. Mas é possível migrar de um sistema monolito para a arquitetura de microserviços aos poucos, um serviço por vez, identificando (capacidades/funcionalidades/escopos) de negócio, implementando-as como um microserviço, e integrando com uso de padrões de acoplamento solto [relaxado?folgado?] (loose coupling). Ao longo do tempo, mais e mais funcionalidades podem ser migradas, até que o monolito se transforme em apenas um outro serviço, ou um microserviço

\subsection{Possibilidade de uso de diferentes ferramentas}

Cada microserviço disponibiliza suas funcionalidades por meio de APIs e contratos de dados em uma rede. A comunicação independe da arquitetura do microserviço faz uso, então cada um pode escolher seu sistema operacional, linguagem e banco de dados.

Isso é especialmente valioso para times multinacionais, pois cada time precisa apenas de conhecimento da arquitetura do microserviço em que trabalha.

\subsection{Alta velocidade}

Com um time responsável por cuidar do ciclo de desenvolvimento e sua automação, a velocidade com que microserviços podem ser desenvolvidos é muito maior do que fazer o equivalente para uma solução monolítica.

\subsection{Reusável e combinável}

Microserviços são reusáveis por natureza. Eles são entidades independentes que provêm funcionalidades em um determinado escopo por meio de (open internet standards). Para criar soluções para o usuário final, multiplos microserviços podem ser combinados.

\subsection{Flexível}

A implantação de microserviços é definida por sua automação. Essa automação pode incluir configuração de cenários diferentes de uso, não apenas para produção, mas também para desenvolvimento e testagem, possibiltando que o microserviço tenha o melhor desempenho em diversos cenários. Para tanto é necessário uso de ferramentas que configurem essa flexibilidade. (tais como as ferramentas de Auto Scaling da AWS)

\subsection{Versionável e Substituível}

Com o controle completo dos cenários de implantação, é possível manter versões diferentes de um mesmo serviço rodando ao mesmo tempo, proporcionando retrocompatibilidade e fácil migração. Além disso, serviços podem ser substituidos sem causar tempo indisponível.

\section{Desafios}

\subsection{[re]Organizaçao}

Organizar o sistema e o time para sustentar uma arquitetura de microserviços é um grande desafio. \emph{If you are part of a command-and-control organization using a waterfall software project management approach, you will struggle because you are not oriented to high-velocity product development. If you lack a DevOps culture and there is no collaboration between development and operations to automate the deployment pipeline, you will struggle}.

Em uma mudança do monolito para microserviços, é recomendado que não sejam feitas mudanças grandes e abruptas na sua organização. Em vez disso, deve-se procurar uma oportunidade com uma iniciativa de negócio para testar a fórmula proposta por \citeonline{Familiar2015} : 

•	 Form a small cross-functional team.

•	 Provide training and guidance on adopting Agile, Scrum, Azure, and microservice architecture.

•	 Provide a separate physical location for this team to work so that they are not adversely effected by internal politics and old habits.

•	 Take a minimal-viable-product approach and begin to deliver small incremental releases of one microservice, taking the process all the way through the lifecycle.

•	 Integrate this service with the existing systems using a loosely coupled approach.

•	 Go through the lifecycle on this microservice several times until you feel comfortable with the process.

•	 Put the core team into leadership positions as you form new cross-functional teams to disseminate the knowledge.

\subsection{Plataforma}

Creating the runtime environment for microservices requires a significant investment in dynamic infrastructure across regionally disperse data centers. If your current on-premises application platform does not support automation, dynamic infrastructure, elastic scale, and high availability, then it makes sense to consider a cloud platform. Microsoft Azure is a microservice platform, and it provides a fully automated dynamic infrastructure, SDKs, and runtime containers along with a large portfolio of existing microservices that you can leverage, such as DocumentDb, Redis In-Memory Cache, and Service Bus, to build your own microservices catalog.

\section{Identificação}

Domain-driven design (design orientado a domínio) é uma tecnica bem consolidada e muito usada. Mas para aplica-la em microserviços, é preciso analisar onde cada peça deve ficar. Em vez de modelar os modelos e os (contextos limitados) separando-os em camadas, pode-se juntar os contextos com seus respectivos modelos, e procurar por possíveis pontos de (separação) da aplicação - um lugar onde a linguagem muda, por exemplo. Isso resultaria em um ponto de partida para separar para uma arquitetura de microserviço.

If you are currently working with a complex layered architecture and have a reasonable domain model defined, the domain model will provide a roadmap to an evolutionary approach to migrating to a microservice architecture. If a domain model does not exist, you can apply domain-driven design in reverse to identify the bounded contexts, the capabilities within the system.

\section{Testes}

Assim como a automação, testar o microserviço em cada passo do \emph{pipeline} de \emph{deploy} é necessário para a entrega rápida de software de qualidade.

Escrever e testar código não muda muito entre as arquiteturas monolítica e de microserviços. Mas além dos métodos mais conhecidos de testes, como test-driven development, teste de unidade e teste funcional, é necessário testar os microserviços conforme passam pelo \emph{pipeline} de \emph{deploy}.

- Internals Testing: Test the internal functions of the service including use of data access, caching, and other cross-cutting concerns.

- Service Testing: Test the service implementation of the API. This is a private internal implementation of the API and its associated models.

- Protocol Testing: Test the service at the protocol level, calling the API over the specified wire protocol, usually HTTP(s).

- Composition Testing: Test the service in collaboration with other services within the context of a solution.

- Scalability/Throughput Testing: Test the scalability and elasticity of the deployed microservice.

- Failover/Fault Tolerance Testing: Test the ability of the microservice to recover after a failure.

- PEN Testing: Work with a third-party software security firm to perform penetration testing. NOTE: This will requires cooperation with Microsoft if you are pen testing microservices deployed to Azure.

\section{Detectável}

Encontrar microserviços em um ambiente distribuido pode ser feito de algumas maneiras diferentes: Hardcode no código, guardar em um arquivo, ou fazer um microserviço para encontrar outros microserviços e disponibilizar suas localizações. Para prover detectabilidade como um serviço será necessário adquirir um produto de terceiros, integrar um projeto aberto, ou desenvolver sua própria solução.

% ---
\section{DevOps}
\label{devops}
% ---

(Manter esta sessão?)

DevOps is a culture that combines new or improved practices, processes, team structures and responsibilities, and tools to maximize the ability of an organization to deliver applications and services quickly [15, 22]. DevOps acts as a process framework that can be used for developing, deploying, and managing MSA [1]. The coexistence of microservices and DevOps enables reusability, decentralized data governance, automation, and built-in scalability [2]. MSA and DevOps have many common characteristics that make them a perfect fit for each other. For instance, DevOps practices and MSA promote the idea of decomposing large problems into smaller pieces and then address them through small cross-functional teams [23]. Containerized microservices can be realized independently because DevOps gives them a favor of continuous integration and deployment. Although it is not compulsory to design software systems based on MSA in DevOps, most of the challenges arisen in DevOps can be resolved by using MSA [17]. This combination is expected to increase the team’s throughput and the overall quality of the system [1, 23]. For example, with MSA and DevOps, Netflix and Amazon engineers can do hundreds of deployments each day [19]. The MSA and DevOps combination brings several other benefits, including frequent software release, reliability and scalability of systems, resilience in the case of failure, and management of decentralized teams to control the application development [24, 25]. Moreover, the DevOps toolchain helps to continually code, build, test, package, release, configure, and monitor the MSA based systems. Furthermore, both MSA and DevOps are designed to offer great agility and operational efficiency for an enterprise

\section{Trabalhos relacionados}

Citar os trabalhos e escrever um parágrafo sobre cada

\section*{"Microservices, IoT and Azure", por Bob Familiar - capítulo 2: "What is a microservice"}

O capítulo 2 do livro de Bob Familiar descreve o que é um microserviço, suas características e implicações, benefícios, e desafios. 

"Microservices do one thing and they do it well". Como é explicado por \citeonline{Familiar2015} , microserviços representam business capabilities definidos usando o design orientado a domínio, são testados a cada passo do \emph{pipeline} de \emph{deploy}, e lançados por meio de automação, como serviços independentes, isolados, altamente escaláveis e resilientes em uma infraestrutura em núvem distribuída. Pertecem a um time único de desenvolvedores, que trata o desenvolvimento do microserviço como um produto, entregando software de alta qualidade em um processo rápido e iterativo com envolvimento do cliente e satisfação como métrica de sucesso.

\section*{"A Systematic Mapping Study on Microservices Architecture in DevOps", por Waseem, M., Liang, P. e Shahin, M.}

Esse trabalho tem o objetivo de sistematicamente identificar, analisar, e classificar a literatura sobre microserviços em DevOps.

Inicialmente o leitor é contextualizado no mundo dos microserviços e a cultura DevOps. Os autores usam a metodologia de pesquisa de um estudo de mapeamento sistemático da literatura publicada entre Janeiro de 2009 e Julho de 2018. Após selecionados 47 estudos, é feita a classificação deles de acordo com os critérios definidos pelos autores, e então é feita a discussão sobre os resultados obtidos - são expostos a quantidade de estudos sobre determinados tópicos em microserviços, problemas e soluções, desafios, métodos de descrição, design patterns, benefícios, suporte a ferramentas, domínios, e implicações para pesquisadores e praticantes.

the key results are: (1) Three themes on the research on MSA in DevOps are “microservices development and operations in DevOps”, “approaches and tool support for MSA based systems in DevOps”, and “MSA migration experiences in DevOps”. (2) 24 problems with their solutions regarding implementing MSA in DevOps are identified. (3) MSA is mainly described by using boxes and lines. (4) Most of the quality attributes are positively affected when employing MSA in DevOps. (5) 50 tools that support building MSA based systems in DevOps are collected. (6) The combination of MSA and DevOps has been applied in a wide range of application domains. Conclusions: The results and findings will benefit researchers and practitioners to conduct further research and bring more dedicated solutions for the issues of MSA in DevOps.

